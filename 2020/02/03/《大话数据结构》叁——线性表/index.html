<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-mystyle.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-mystyle.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-mystyle.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://Chun-CE.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","width":200,"display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="《大话数据结构》第三章《线性表》笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《大话数据结构》叁——线性表">
<meta property="og:url" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/">
<meta property="og:site_name" content="Chun-CE">
<meta property="og:description" content="《大话数据结构》第三章《线性表》笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-2-1.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-4-1.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-4-4.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-6-2.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-6-3.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-6-4.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-6-7.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-6-8.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-6-9.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-6-10.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-8-1.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-8-2.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-8-4.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-8-5.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-9-1.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-12-1.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-12-2.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-12-3.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-13-3.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-13-4.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-13-5.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-13-6.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-13-7.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-14-3.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-14-4.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-14-5.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-14-6.jpg">
<meta property="og:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-15-1.jpg">
<meta property="article:published_time" content="2020-02-03T03:15:32.000Z">
<meta property="article:modified_time" content="2020-02-05T15:12:20.057Z">
<meta property="article:author" content="郭子淳">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/%E5%9B%BE3-2-1.jpg">

<link rel="canonical" href="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>《大话数据结构》叁——线性表 | Chun-CE</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chun-CE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>主页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chun-ce.github.io/2020/02/03/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%8F%81%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/blog_face2.jpg">
      <meta itemprop="name" content="郭子淳">
      <meta itemprop="description" content="越努力，越幸运！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chun-CE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《大话数据结构》叁——线性表
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-03 11:15:32" itemprop="dateCreated datePublished" datetime="2020-02-03T11:15:32+08:00">2020-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-05 23:12:20" itemprop="dateModified" datetime="2020-02-05T23:12:20+08:00">2020-02-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">《大话数据结构》学习笔记</span>
                  </a>
                </span>
            </span>

          
            <div class="post-description">《大话数据结构》第三章《线性表》笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>零或多个数据元素的有限序列<br>弱将线性表记为($a1,…,a_{i-1},a_i,a_{i+1},…,a_n$),则表中$a_{i-1}$领先于$a_i$的直接猴急元素.当i=1,2,…,n-1时,$a_i$有且仅有一个直接后继,当i=2,3,…,n时,$a_i$有且仅有一个直接前驱.如图3-2-1所示.<br><img src="图3-2-1.jpg" alt="图3-2-1">  </p>
<h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>线性表的抽象数据类型定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">Data</span><br><span class="line">    线性表的数据对象集合为&#123;a_1,a_2,...,a_n&#125;,每个元素的</span><br><span class="line">    类型均为DataType.其中,出第一个元素a_1外,每一个元素</span><br><span class="line">    有且只有一个前驱元素,除了最后一个元素a_n外,每一个元</span><br><span class="line">    素有且只有一个直接后级元素.元素之间的关系是一对一的关</span><br><span class="line">    系.</span><br><span class="line">    Operation</span><br><span class="line">        InitList(*L);           初始化操作,建立一个空的线性表L.</span><br><span class="line">        ListEmpty(L);           若线性表为空,返回true,否则返回false.</span><br><span class="line">        ClearList(*L);          将线性表清空.</span><br><span class="line">        GetElem(L,i,*e);        将线性表L中的第i个位置元素返回给e.</span><br><span class="line">        LocateElem(L,e);        在线性表L中查找与给定值e相等的元素,如果查找成功,返回该元素在表中的序号表示成功;否则,返回0表示失败.</span><br><span class="line">        ListInsert(*L,i,e);     在线性表L中的第i个位置插入新元素e.</span><br><span class="line">        ListDelete(*L,i,*e);    删除线性表L中第i个位置元素,并用e返回其值.</span><br><span class="line">        ListLength(L);          返回线性表L的元素个数.</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><br>对于不同的应用,线性表的基本操作是不同的,上述操作是最基本的,对于实际问题中涉及的关于线性表的更复杂的操作,完全可以用这些基本操作的组合来实现.<br>如,现要使得A=AUB,即把存在于B中而不存在与A中的数据元素插入到A中即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;La表示集合A,Lb表示集合B</span><br><span class="line">void union(List *La,List Lb)</span><br><span class="line">&#123;</span><br><span class="line">    int La_len,Lb_len,i;</span><br><span class="line">    ElemType e;                         &#x2F;&#x2F;声明与La和Lb相同的数据元素e</span><br><span class="line">    La_len &#x3D; ListLength(La);            &#x2F;&#x2F;求线性表的长度</span><br><span class="line">    lb_len &#x3D; ListLength(Lb);</span><br><span class="line">    for (i&#x3D;1;i&lt;&#x3D;Lb_len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetElem(Lb,i,e);                &#x2F;&#x2F;取Lb中第i个数据元素赋给e</span><br><span class="line">        if(!LocateElem(La,e,equal))     &#x2F;&#x2F;La中不存在和e相同数据元素</span><br><span class="line">            ListInsert(La,++La_len,e);  &#x2F;&#x2F;插入</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><h3 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h3><p>线性表的顺序存储结构,指的是用一段地址连续的存储单元一次存储线性表的数据元素.<br><img src="图3-4-1.jpg" alt="图3-4-1">  </p>
<h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><p>线性表的顺序存储的结构代码.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define MAXSIZE 20          &#x2F;&#x2F;存储空间初始分配量</span><br><span class="line">typedef int ElemType;       &#x2F;&#x2F;ElemType类型根据实际情况而定,这里假设为int</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data(MAXSIZE); &#x2F;&#x2F;数组存储数据元素,最大值为MAXSIZE</span><br><span class="line">    int length;             &#x2F;&#x2F;线性表当前长度</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><br>得到描述顺序存储结构需要三个属性:</p>
<ul>
<li>存储空间的起始位置:数组data,他的存储位置就是存储空间的存储位置.</li>
<li>线性表的最大存储容量:数组长度MAXSIZE.</li>
<li>线性表的当前长度:length.</li>
</ul>
<h3 id="数组长度与线性表长度的区别"><a href="#数组长度与线性表长度的区别" class="headerlink" title="数组长度与线性表长度的区别"></a>数组长度与线性表长度的区别</h3><ul>
<li>数组长度是存放线性表的存储空间的长度,存储分配后这个量一般是不变的.一般高级语言如C、VB、C++都可以用编程手段实现动态分配数组,但这样会带来性能上的损耗.  </li>
<li>线性表的长度是线性表中数据元素的个数,随着线性表掺入和删除在操作的进行,这个量是变化的.</li>
<li>线性表的长度永远小于等于数组的长度.</li>
</ul>
<h3 id="地址的计算方法"><a href="#地址的计算方法" class="headerlink" title="地址的计算方法"></a>地址的计算方法</h3><p>存储器中的每个存储单元都有自己的编号,这个编号成为地址.假设当前数据类型每个数据元素占用的存储空间为c,那么:<br>线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足下列关系(LOC为获得存储位置的函数):<br><code>LOC(a_{i+1})=Loc(a_i)+c</code><br>所以对于第i个数据元素a_i的存储位置可以由a_1推算得出:<br><code>LOC(a_i)=LOC(a_1)+(i-1)*c</code><br><img src="图3-4-4.jpg" alt="图3-4-4"></p>
<hr>
<h2 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h2><h3 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h3><p>GetElem实际上就是将线性表L中的第i个位置元素值返回,在程序中就是把数组的第i-1下标的值返回.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">typedef int Status;</span><br><span class="line">&#x2F;&#x2F;Status是函数的类型,其值是函数结果状态代码,如OK等</span><br><span class="line">&#x2F;&#x2F;初始条件:顺序线性表L已存在,1 &lt;&#x3D; i &lt;&#x3D;ListLength</span><br><span class="line">&#x2F;&#x2F;操作结果:用e返回L中第i个数据元素的值.</span><br><span class="line">Status GetElem(SqList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    if(L.length&#x3D;&#x3D;0 || i&lt;1 || i&gt;L.length)</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e &#x3D; L.data[i-1];</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>ListInsert(*L,i,e),在线性表L中的第i个位置插入新元素e.<br>插入算法的思路:</p>
<ul>
<li>如果插入的位置不合理,抛出异常;</li>
<li>如果线性表长度大于等于数组长度,则抛出异常或动态增加容量;</li>
<li>从最后一个元素开始向前便利到第i个位置,分别将他们都向后移动一个位置;</li>
<li>将要插入的元素填入位置i处;</li>
<li>表长加1.</li>
</ul>
<p>实现代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*初始条件:顺序线性表L已存在,1&lt;&#x3D;i&lt;&#x3D;ListLength(L)*&#x2F;</span><br><span class="line">&#x2F;*操作结果:在L中第i个位置之前插入新的数据元素e,L的长度加1*&#x2F;</span><br><span class="line">Status ListInsert(SqList *L,int i,Ele,Type e)</span><br><span class="line">&#123;</span><br><span class="line">    int k;</span><br><span class="line">    if (L-&gt;length&#x3D;&#x3D;MAXSIZE)                 &#x2F;&#x2F;顺序线性表已经满</span><br><span class="line">        return ERROR;</span><br><span class="line">    if (i&lt;1 || i&gt;L-&gt;length+1)               &#x2F;&#x2F;当i不在范围内时</span><br><span class="line">        return ERROR;</span><br><span class="line">        if (i&lt;&#x3D;L-&gt;length)                   &#x2F;&#x2F;若插入数据位置不在表内</span><br><span class="line">        &#123;</span><br><span class="line">            for(k&#x3D;L-&gt;length-1;k&gt;&#x3D;i-1;k--)   &#x2F;&#x2F;将要插入位置后数据元素项后移动一位</span><br><span class="line">                L-&gt;data[k+1]&#x3D;L-&gt;data[k];</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;data[i-1]&#x3D;e;                     &#x2F;&#x2F;将新元素插入</span><br><span class="line">        L-&gt;length++;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除算法的思路:</p>
<ul>
<li>如果删除位置不合理,抛出异常;</li>
<li>去除删除元素;</li>
<li>从删除元素位置开始遍历到最后一个元素位置,分别将他们都镶嵌移动一个位置;</li>
<li>表长减1.<br>实现代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*初始条件:顺序线性表L已经存在,1&lt;&#x3D;i&lt;&#x3D;ListLength(L)*&#x2F;</span><br><span class="line">&#x2F;*操作结果:删除L的第i个数据元素,并用e返回其值,L的长度减1*&#x2F;</span><br><span class="line">Status ListDelete(SqList *L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int k;</span><br><span class="line">    if (L-&gt;length&#x3D;&#x3D;0)                   &#x2F;&#x2F;线性表为空</span><br><span class="line">        return ERROR;</span><br><span class="line">    if (i&lt;1 || i&gt;L-&gt;length)             &#x2F;&#x2F;删除位置不正确</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e&#x3D;L-&gt;data[i-1];</span><br><span class="line">    if (i&lt;L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        for(k&#x3D;i;k&lt;L-&gt;length;k++)</span><br><span class="line">            L-&gt;data[k-1]&#x3D;L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h3><div class="table-container">
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>无序为表示表中元素之间的逻辑关系而增加而外的存储空间</td>
<td>插入和删除操作需要移动大量元素</td>
</tr>
<tr>
<td>可以快速地存取表中任意未知的元素</td>
<td>当线性表长度变化较大时,难以确定存储空间的容量</td>
</tr>
<tr>
<td></td>
<td>造成存储空间的”碎片”</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><p>线性表的顺序存储结构最大的缺点就是插入和删除时需要移动大量元素,而链式存储结构的发明就解决了这个难题.</p>
<h3 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h3><p>在顺序结构中,每个数据元素只需存储数据元素信息,而在链式结构中,除了要存储数据元素外,还要存储他的后继元素的存储地址.<br>为了表示每个数据元素a_i与其直接后继数据元素a_{i+1}之间的逻辑关系,对数据元素a_i来说,除了是存储其本身的信息之外,还需存储一个知识其直接后继的信息(及即直接后继的存储位置).我们把存储数据元素信息的域称为<strong>数据域</strong>,把存储直接后继位置的域称为<strong>指针域</strong>.指针域中存储的信息乘坐指针或链.这两部分信息醉成数据元素a_i的存储影响,称为<strong>结点(Node)</strong>.<br>n个结点(a_i的存储映像)链结成一个链表,即为线性表(a_1,a_2,…,a_n)的链式存储结构,因为此链表的每个结点中质保函一个指针域,所以叫做<strong>单链表</strong>.如图3-6-2<br><img src="图3-6-2.jpg" alt="图3-6-2"><br>与数组一样,链表也要有头有尾,我们把链表中第一个结点的存储位置叫做<strong>有指针</strong>,规定链表的最后一个结点的指针为<strong>“空”(通常用NULL或”^”符号表示,如图3-6-3)<br><img src="图3-6-3.jpg" alt="图3-6-3"><br>有时为了更加方便的对链表进行操作,会在单链表的第一个结点前附设一个结点,称为</strong>头结点**.头结点可以不存储任何信息,只要有个指针就可以.如图3-6-4<br><img src="图3-6-4.jpg" alt="图3-6-4">  </p>
<h3 id="头指针与头结点的异同"><a href="#头指针与头结点的异同" class="headerlink" title="头指针与头结点的异同"></a>头指针与头结点的异同</h3><div class="table-container">
<table>
<thead>
<tr>
<th>头指针</th>
<th>头结点</th>
</tr>
</thead>
<tbody>
<tr>
<td>头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针</td>
<td>头结点是为了操作的同意和方便而设立的,放在第一元素的结点之前,其数据域一般无意义(也可存放链表的长度)</td>
</tr>
<tr>
<td>头指针具有标识作用,所以常用头指针冠以链表的名字</td>
<td>有了头结点,对在第一元素借点钱插入结点和删除第一节点等操作就与其他普通结点操作统一了.</td>
</tr>
<tr>
<td>无论链表是否为空,头指针均不为空.头指针是链表的必要元素</td>
<td>头结点不一定是链表的必要元素</td>
</tr>
</tbody>
</table>
</div>
<h3 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h3><p>链式存储结构存储示意图(图3-6-7)<br><img src="图3-6-7.jpg" alt="图3-6-7"><br>带有头结点的单链表(图3-6-8)<br><img src="图3-6-8.jpg" alt="图3-6-8"><br>空链表(图3-6-9)<br><img src="图3-6-9.jpg" alt="图3-6-9"></p>
<p>单链表在C语言中可以使用结构指针来描述(啥叫结构指针?)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*线性表的单链表存储结构*&#x2F;</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">typedef struct Node *LinkList;      &#x2F;&#x2F;定义LinkList</span><br></pre></td></tr></table></figure><br>假设p是指向线性表第i个元素的指针,则该节点a_i的数据域我们可以用p-&gt;data来表示,p-&gt;data的值是一个数据元素,结点a_i的指针域可以用p-&gt;next来表示,p-&gt;next的值就是一个指针.也就是说如果p-&gt;data=a_i,那么p-&gt;next-&gt;data=a_{i+1}. 图3-6-10<br><img src="图3-6-10.jpg" alt="图3-6-10">  </p>
<hr>
<h2 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h2><p>单链表获取第i个元素的数据的操作为GetElem.<br>获取链表第i个数据的算法思路:  </p>
<ul>
<li>声明一个结点p指向链表第一个结点,初始化j从1开始;</li>
<li>当j&lt; i时,就遍历链表,让p的指针向后移动,不但指向下一个结点,j累加1;</li>
<li>若到链表末尾p为空,则说明第i个元素不存在;</li>
<li>否则查找成功,返回结点p的数据<br>实现代码算法如下:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*初始条件:顺序线性表L已存在,1&lt;&#x3D;i&lt;&#x3D;ListLength(L)*&#x2F;</span><br><span class="line">&#x2F;*操作结果:用e返回L中第i个数据元素的值*&#x2F;</span><br><span class="line">Status GetElem(LinkList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p;         &#x2F;&#x2F;声明一结点p</span><br><span class="line">    p &#x3D; L-&gt;next;        &#x2F;&#x2F;让p指向链表L的第一个结点</span><br><span class="line">    j &#x3D; 1;              &#x2F;&#x2F;j为计数器</span><br><span class="line">    while (p &amp;&amp; j&lt;i&gt;)   &#x2F;&#x2F;p不为空或者计数器j还没有等于i时,循环继续</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; p-&gt;next;    &#x2F;&#x2F;让p指向下一个结点</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!p || j&gt;i)</span><br><span class="line">        return ERROR;</span><br><span class="line">        *e &#x3D; p-&gt;data;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h2><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p><img src="图3-8-1.jpg" alt="图3-8-1"><br>单链表的插入只需要改变插入点两侧的指针即可<br><code>s-&gt;next=p-&gt;next;   p-&gt;next=s;</code><br>这两句代码实际上就是让p的后继结点改成s的后继结点,再把结点s变成p的后继结点.图3-8-2<br><img src="图3-8-2.jpg" alt="图3-8-2"><br>对于单链表的表头和表位的特殊情况.操作仍然是一样的,图3-8-4<br><img src="图3-8-4.jpg" alt="图3-8-4"><br>单链表第i个数据插入的算法思路:  </p>
<ol>
<li>声明一结点p指向链表第一个结点,初始化j从1开始;</li>
<li>当j&lt; i时,就遍历链表没让p的指针向后移动,不断指向下一个结点,j累加1;</li>
<li>若链表末尾p为空,则说明第i个元素不存在;</li>
<li>否则查找成功,在系统中生成一个空结点s;</li>
<li>将数据元素e赋值给s-&gt;data;</li>
<li>单链表的插入标准语句<code>s-&gt;next=p-&gt;next; p-&gt;next=s;</code>顺序不能搞反.</li>
<li>返回成功.<br>实现代码算法如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*初始条件:书序线性表L已经存在,且1&lt;&#x3D;i&lt;&#x3D;ListLength(L)*&#x2F;</span><br><span class="line">&#x2F;*操作结果:在L中第i个位置之前插入新的数据元素e,L的长度加1*&#x2F;</span><br><span class="line">Status ListInsert(LinkList *L,int i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p,s;</span><br><span class="line">    p &#x3D; *L;</span><br><span class="line">    j &#x3D; 1;</span><br><span class="line">    while(p &amp;&amp; j&lt;i)         &#x2F;&#x2F;寻找第i个结点</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!p || j&gt;i)</span><br><span class="line">        return ERROR;       &#x2F;&#x2F;第i个元素不存在</span><br><span class="line">    s &#x3D; (LinkList)malloc(sizeof(Node));&#x2F;&#x2F;生成新结点(C标准函数)</span><br><span class="line">    s-&gt;data &#x3D; e;            &#x2F;&#x2F;将数据元素e赋值给s-&gt;data</span><br><span class="line">    s-&gt;next &#x3D; p-next;       &#x2F;&#x2F;将p的后继结点赋值给s的后继</span><br><span class="line">    p-&gt;next &#x3D; s;            &#x2F;&#x2F;将s赋值给p的后继</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<em>malloc:作用是生成一个新的结点,其类型与Node是一样的,其实质就是在内存中找了一小块空地,准备用来存放e数据s结点.</em><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><img src="图3-8-5.jpg" alt="图3-8-5"><br>代码实现<code>q=p-&gt;next; p-&gt;next=q-&gt;next;</code><br>就是让p的后继的后继结点改成p的后继结点<br>单链表第i个数据删除结点的算法思路:</li>
<li>声明一结点p指向链表第一个结点,初始化j从1开始;</li>
<li>当j&lt; i时,就遍历链表,让p的指针向后移动,不断指向下一个结点,j累加1;</li>
<li>若到链表末尾p为空,则说明第i个元素不存在;</li>
<li>否则查找成功,将欲删除的结点p-&gt;next赋值给q;</li>
<li>单链表的删除标准语句p-&gt;next=q-&gt;next;</li>
<li>将q结点中的数据赋值给e,作为返回;</li>
<li>释放q结点;</li>
<li>返回成功.<br>实现代码算法如下:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*初始条件: 顺序线性表L一存在,1&lt;&#x3D;i&lt;&#x3D;ListLength(L)*&#x2F;</span><br><span class="line">&#x2F;*操作结果: 删除L的第i个数据元素,并用e返回其值,L的额长度减1*&#x2F;</span><br><span class="line">Status ListDelete(LinkList *L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p &#x3D; *L;</span><br><span class="line">    j &#x3D; 1;</span><br><span class="line">    whiel (p-&gt;next &amp;&amp; j&lt;i&gt;)     &#x2F;&#x2F;遍历寻找第i个元素</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!(p-&gt;next) || j&gt;i)</span><br><span class="line">        return ERROR;           &#x2F;&#x2F;第i个元素不存在</span><br><span class="line">    q &#x3D; p-&gt;next;</span><br><span class="line">    p-&gt;next &#x3D; q-&gt;next;          &#x2F;&#x2F;将q的后继赋值给p的后继</span><br><span class="line">    *e &#x3D; q-&gt;data;               &#x2F;&#x2F;将q结点中的数据给e</span><br><span class="line">    free(q);                    &#x2F;&#x2F;让系统回收此结点,释放内存</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
free:作用是让系统回收一个Node结点,释放内存.<br>显然,对于插入或删除数据月欧尼反的操作,单链表的效率优势越明显.</li>
</ol>
<hr>
<h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><p>创建单链表的过程就是一个动态生成链表的过程.即从”空表”的初始状态起,一次建立个元素的结点,并逐个插入链表.<br>单链表整表创建的算法思路:  </p>
<ol>
<li>声明一结点p和计数器变量i;</li>
<li>初始化一空链表L;</li>
<li>让L的头结点的指针指向NULL,即建立一个带头结点的单链表;</li>
<li>循环:<ol>
<li>生成一新结点赋值给p</li>
<li>随机生成一数字赋值给p的数据域p-&gt;data;</li>
<li>将p插入到头结点与前一新结点之间.<br>实现代码算法如下:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*随机产生n个元素的值,建立带表头结点的单恋线性表L(头插法)*&#x2F;</span><br><span class="line">void CreateListHead(LinkList *L,int n)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    int i;</span><br><span class="line">    srand(time(0));                             &#x2F;&#x2F;初始化随机数种子</span><br><span class="line">    *L &#x3D; (LinkList)malloc(sizeof(Node));</span><br><span class="line">    (*L)-&gt;next &#x3D; NULL;                          &#x2F;&#x2F;先建立一个带头结点的单链表</span><br><span class="line">    for (i&#x3D;0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; (LinkList)malloc(sizeof(Node));     &#x2F;&#x2F;生成新结点</span><br><span class="line">        p-&gt;data &#x3D; rand()%100+1;                 &#x2F;&#x2F;随机生成100以内的数字</span><br><span class="line">        p-&gt;next &#x3D; (*L)-&gt;next;</span><br><span class="line">        (*L)-&gt;next &#x3D; p;                         &#x2F;&#x2F;插入到表头</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上代码用到的是<strong>插队</strong>的办法,就是时钟让新结点在第一的位置,简称<strong>头插法</strong>,图3-9-1<br><img src="图3-9-1.jpg" alt="图3-9-1"><br>有<strong>头插法</strong>当然也有<strong>尾插法</strong>,尾插法就是每次把新结点插在终端结点的后面.<br>实现代码算法如下:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*随机产生n个元素的值,建立带表头结点的单链线性表L(尾插法)*&#x2F;</span><br><span class="line">void CreateListTail(LinkList *L,int n)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p,r;</span><br><span class="line">    int i;</span><br><span class="line">    srand(time(o));                         &#x2F;&#x2F;初始化随机化种子</span><br><span class="line">    *L &#x3D; (LinkList)malloc(sizeof(Node));    &#x2F;&#x2F;为整个线性表</span><br><span class="line">    r &#x3D; *L;                                 &#x2F;&#x2F;r为指向尾部的结点</span><br><span class="line">    for (i&#x3D;0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; (Node *)malloc(sizeof(Node));   &#x2F;&#x2F;生成新结点</span><br><span class="line">        p-&gt;data &#x3D; rand()%100+1;             &#x2F;&#x2F;生成100以内随机数</span><br><span class="line">        r-&gt;next&#x3D;p;                          &#x2F;&#x2F;将表尾终端结点的指针指向新结点</span><br><span class="line">        r &#x3D; p;                              &#x2F;&#x2F;将当前的新节点定义为表位终端结点</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next &#x3D; NULL;                         &#x2F;&#x2F;表示当前链表结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意L与r的关系,L狮子整个单链表,而r是指向尾结点的变量,r会随着循环不断地变化结点,而L会随着循环不断增长为多结点链表.  </li>
</ol>
</li>
</ol>
<hr>
<h2 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h2><p>单链表整表删除的算法思路如下:  </p>
<ol>
<li>声明一结点p和q;</li>
<li>将第一个结点赋值给p;</li>
<li>循环:<ol>
<li>将下一节点赋值给q;</li>
<li>释放p;</li>
<li>将q赋值给p.<br>实现代码算法如下:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*初始条件:顺序线性表L已存在*&#x2F;</span><br><span class="line">&#x2F;*操作结果:将L重置为空表*&#x2F;</span><br><span class="line">Status ClearList(LinkList *L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p &#x3D; (*L)-&gt;next;         &#x2F;&#x2F;p指向第一个结点</span><br><span class="line">    while(p)                &#x2F;&#x2F;直到表尾</span><br><span class="line">    &#123;</span><br><span class="line">        q&#x3D;p-&gt;next;</span><br><span class="line">        free(p);</span><br><span class="line">        p&#x3D;q;</span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next&#x3D;NULL;        &#x2F;&#x2F;头结点指针域为空</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="单链表结构与顺序存储结构的优缺点"><a href="#单链表结构与顺序存储结构的优缺点" class="headerlink" title="单链表结构与顺序存储结构的优缺点"></a>单链表结构与顺序存储结构的优缺点</h2><html>
    <table style="margin-left: auto; margin-right: auto;">
        <tr>
            <td>
                <!--左侧内容-->
                <b>存储分配方式</b>
                <p>· 顺序存储结构用一段连续的存储单元一次存储线性表的数据元素</p>
                <p>· 单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素</p>
            </td>
            <td>
                <!-- 中间内容 -->
                 <b>时间性能</b>
                 <p>· 查找</p>
                 <p>&nbsp&nbsp·顺序存储结构O（1）</p>
                 <p>&nbsp&nbsp·单链表O（n）</p>
                 <p>· 插入和删除</p>
                 <p>&nbsp&nbsp· 顺序存储结构需要平均移动表长一般的元素，为O(n)</p>
                 <p>&nbsp&nbsp· 单链表在线出某位置的指针后，插入和删除时间仅为O(1)</p>
            </td>
            <td>
                <!--右侧内容-->
                <b>空间性能</b>
                <p>· 顺序存储结构需要预分配存储空间，分大了浪费，分小了容易溢出</p>
                <p>· 单链表不需要分配存储空间，只要有就可以分配，元素个数也不熟限制</p>
            </td>
        </tr>
    </table>
</html>

<hr>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>对于某些没有指针的编程语言，有人提出了<strong>用数组描述的链表，称为静态链表</strong>。<br>静态链表中代替指针的数组都是由两个数据域组成，<strong>data</strong>和<strong>cur</strong>，数据域data用来存放数据元素，游标cur相当于单链表中的next指针，存放钙元素的后继在数组中的下标。<br>为了方便插入数据，应把数组建立的足够大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*线性表的静态链表存储结构*&#x2F;</span><br><span class="line">#define MAXSIZE 1000</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    int cur;</span><br><span class="line">&#125;Component,StaticLinkList(MAXSIZE);</span><br></pre></td></tr></table></figure><br>另外,数组第一个和最后一个元素作为特殊元素处理,不存储数据.通常把未被使用的数组元素称为<strong>备用链表</strong>.数组第一个元素,即下标为0的元素的cur就存放备用链表的第一个结点的下标;而数组的最后一个元素的cur则存放第一个有数值的元素的下标,相当于单链表中头结点作用,当整个链表为空时,则为$0^2$.图3-12-1<br><img src="图3-12-1.jpg" alt="图3-12-1"><br>此时的图示相当于初始化的数组状态,见下面代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*将一位数组spqce中各分量链成一备份链表*&#x2F;</span><br><span class="line">&#x2F;*space[0].cur为头指针,&quot;0&quot;表示空指针*&#x2F;</span><br><span class="line">Status InitList(StaticLinlList space)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i&#x3D;0;i&lt;MAXSIZE-1;i++)</span><br><span class="line">        space[i].cur &#x3D; i+1; </span><br><span class="line">    spacee[MAXSIZE-1].cur &#x3D; 0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>假设我们已经将数据存入静态链表,比如分别存放着”甲””乙””丙””丁””戊””己””庚”等数据,则将如图3-12-2所示<br><img src="图3-12-2.jpg" alt="图3-12-2"></p>
<h3 id="静态链表的插入操作"><a href="#静态链表的插入操作" class="headerlink" title="静态链表的插入操作"></a>静态链表的插入操作</h3><p>静态链表要解决的问题:如何用惊扰模拟动态链表结构的存储空间分配,需要时申请,无用时释放.<br>在动态链表中,结点的申请和释放分别借用malloc()和free()两个函数实现,在静态链表中,操作的是数组,所以要自己实现这两个函数,才可以做插入和删除的操作.<br>为了辨明数组中那些分量未被使用,解决办法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表,每当进行插入时,便可以从备用链表上取得第一个结点作为待插入的新结点.<br>类malloc函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*若备用空间链表非空,则返回分配的结点下标,否则返回0*&#x2F;</span><br><span class="line">int Malloc_SLL(StaticLinkList space)</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; space[0].cur;               &#x2F;&#x2F;当前数组第一个元素的cur存的值</span><br><span class="line">                                        &#x2F;&#x2F;就是要返回的第一个备用空闲的下标</span><br><span class="line">    if (space[0].cur)</span><br><span class="line">        space[0].cur &#x3D; space[i].cur;    &#x2F;&#x2F;由于要拿出一个分量来使用了</span><br><span class="line">                                        &#x2F;&#x2F;所以要把它的下一个分量用来做备用</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>插入实现代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*在L中第i个元素之间插入新的数据元素e*&#x2F;</span><br><span class="line">Status ListInsert(StaticLinlList L,int i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int j,k,l;</span><br><span class="line">    k &#x3D; MAX_SIZE - 1;</span><br><span class="line">    if (i &lt; 1 || i &gt; ListLength(L) + 1)</span><br><span class="line">        return ERROR;</span><br><span class="line">    j &#x3D; Malloc_SSL(L);</span><br><span class="line">    if(j)</span><br><span class="line">    &#123;</span><br><span class="line">        L[j].data &#x3D; e;</span><br><span class="line">        for (l &#x3D; 1;l &lt;&#x3D; i-1;l++)</span><br><span class="line">            k &#x3D; L[k].cur;</span><br><span class="line">        L[j].cur &#x3D; L[k].cur;</span><br><span class="line">        L[k].cur &#x3D; j;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    return ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果我们想在”乙”和”丁”之间插入”丙”则:</p>
<ul>
<li>当我们执行插入语句是,我们的目的是要在”乙”和”丁”之间插入”丙”.调用代码是,输入i值为3.</li>
<li>第4行让k=MAX_SIZE -1=999.</li>
<li>第7行,j=Malloc_SSL(L)=7.此时下标为0的cur也因为7要被占用而更改备用链表的值8.</li>
<li>第11~12行,for循环l由1到2,执行两次.代码k = L[k].cur;使得k=999,得到k=L[999].cur=1,再得到k=L[1].cur=2.</li>
<li>第13行,L[j].cur=L[k].cur;因j=7,k=2得到L[7].cur=L[2].cur=3.这就是刚才我说的让”丙”把它的cur改为3的意思.</li>
<li>第14行,L[k].cur = j;意思就是L[2].cur=7.也就是让”乙”得到点好处,把它的cur改为指向”丙”的下标7.  </li>
<li>就这样,我们实现了在数组中,实现不移动元素,却插入了数据的操作,图3-12-3<br><img src="图3-12-3.jpg" alt="图3-12-3"></li>
</ul>
<h3 id="静态链表的删除操作"><a href="#静态链表的删除操作" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h3><p>和前面一样,删除元素是,原来是要释放结点的函数free().现在我们也得自己实现它:  </p>
<p>删除实现代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*删除在L中第i个数据元素e*&#x2F;</span><br><span class="line">Status ListDelete(StaticLinkList L,int i)</span><br><span class="line">&#123;</span><br><span class="line">    int j,k;</span><br><span class="line">    if (i&lt;1 || i&gt;ListLength(L))</span><br><span class="line">        return ERROR;</span><br><span class="line">    k &#x3D; MAX_SIZE - 1;</span><br><span class="line">    for (j &#x3D; 1;j &lt;&#x3D; i-1;j++)</span><br><span class="line">        k &#x3D; L[k].cur;</span><br><span class="line">    j &#x3D; L[k].cur;</span><br><span class="line">    L[k].cur &#x3D; L[j].cur;</span><br><span class="line">    Free_SSL(L,j);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Free_SLL:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Free_SSL(StaticLinkList space,int k)</span><br><span class="line">&#123;</span><br><span class="line">    space[k].cur &#x3D; space[0].cur;</span><br><span class="line">    space[0].cur &#x3D; k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ListLength():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*初始条件:静态链表L已存在.操作结果:返回L中数据元素个数*&#x2F;</span><br><span class="line">int ListLength(StaticLinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    int j&#x3D;0;</span><br><span class="line">    int i&#x3D;L[MAXSIZE-1].cur;</span><br><span class="line">    while(i)</span><br><span class="line">    &#123;</span><br><span class="line">        i&#x3D;L[i].cur;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="静态链表优缺点"><a href="#静态链表优缺点" class="headerlink" title="静态链表优缺点"></a>静态链表优缺点</h3><div class="table-container">
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>在插入和删除操作时m,只需要修改游标,不需移动元素,从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点.</td>
<td>没有解决连续存储分配带来的表长难以确定的问题</td>
</tr>
<tr>
<td></td>
<td>失去了顺序存储结构随机存取的特性</td>
</tr>
</tbody>
</table>
</div>
<p>总的来说,静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法,以备不时之需  </p>
<hr>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>将单链表中终端结点的指针端由空指针改为指向头结点,就是整个单链表形成一个环,这种头尾详解的单链表称为单循环链表,简称循环链表(circular linked list)<br>循环链表能够解决如何从中间一个结点出发,访问到链表的全部结点的问题.<br>为了使空链表与费空链表处理一致,通常会设立一个头结点,但这并不是强行要求<br>循环列表带有头结点的空链表如 图3-13-3所示<br><img src="图3-13-3.jpg" alt="图3-13-3"><br>非空的循环链表如图3-13-4所示<br><img src="图3-13-4.jpg" alt="图3-13-4"></p>
<p>其实循环链表和单链表的主要差异就在于循环的判断条件上,原来是判断p-next是否为空,现在是判断p-&gt;next是不是等于头结点.  </p>
<p>为了方便查找链表的终端结点,可以对链表进行改造,不再使用头指针表示链表,而是使用尾指针.如图3-13-5<br><img src="图3-13-5.jpg" alt="图3-13-5"><br>从上图可以看出,终端结点用尾指针rear指示,则查找终端结点是O(1),而开始结点,其实就是rear-&gt;next-&gt;next,时间复杂度同样是O(1).<br>使用尾指针表示链表在将两个循环链表合并成一个表是,就会非常简单.<br>现有两个链表,他们的尾指针分别是rearA和rearB,如图3-13-6所示<br><img src="图3-13-6.jpg" alt="图3-13-6"><br>想要将其合并,只需如下操作,如图3-13-7所示<br><img src="图3-13-7.jpg" alt="图3-13-7"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p&#x3D;rearA-&gt;next;                   &#x2F;&#x2F;保存A表的头结点即①</span><br><span class="line">rearA-&gt;next&#x3D;rearB-&gt;next-&gt;next;  &#x2F;&#x2F;将本市指向B表的第一个结点(不是头结点)赋值给rearA-&gt;next即②</span><br><span class="line">rearB-&gt;next&#x3D;p;                  &#x2F;&#x2F;将原A表的头结点赋值给rearB-&gt;next,即③</span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表(double linked list)是在单链表的每个结点中再设置一个指向其前驱结点的指针域.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*线性表的双向链表存储结构*&#x2F;</span><br><span class="line">typedef struct DulNode</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct DuLNode *prior;  &#x2F;&#x2F;直接前驱指针</span><br><span class="line">    struct DuLNode *next;   &#x2F;&#x2F;直接后继指针</span><br><span class="line">&#125;DulNode,*DuLinkList;</span><br></pre></td></tr></table></figure><br>既然单链表也可以由循环链表,那么双向链表当然也可以是循环表.<br>双向链表的循环带头结点的空链表如图3-14-3所示<br><img src="图3-14-3.jpg" alt="图3-14-3"><br>非空的循环的带头结点的双向链表如图3-14-4所示<br><img src="图3-14-4.jpg" alt="图3-14-4"><br>双向链表中结点p的前驱的后继仍然是p,后继的前驱也仍然是p:<br><code>p-&gt;next-&gt;prior = p = p-&gt;prior-&gt;next</code><br>双向链表的很多操作仍和单链表相同,比如求长度(ListLength),查找元素(GetElem),获得位置(LocateElem)等,皆只需涉及一个方向的指针即可.<br>但双向链表在进行插入与删除操作时,会稍稍多几个步骤,毕竟要修改两个指针<br>插入操作(顺序很重要):<br>现假设存储元素e的结点为s,要实现将结点s插入到结点p和p-&gt;next之间需要以下几步,如图3-14-5所示<br><img src="图3-14-5.jpg" alt="图3-14-5"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; prior &#x3D; p;             &#x2F;&#x2F;把p赋值给s的前驱</span><br><span class="line">s -&gt; next &#x3D; p -&gt; next;      &#x2F;&#x2F;把p-&gt;next赋值给s的后继</span><br><span class="line">p -&gt; next -&gt; prior &#x3D; s;     &#x2F;&#x2F;把s赋值给p-&gt;next的前驱</span><br><span class="line">p -&gt; next &#x3D; s;              &#x2F;&#x2F;把s赋值给p的后继</span><br></pre></td></tr></table></figure><br>删除操作:<br>欲删除结点p,只需两步,如图3-14-6所示:<br><img src="图3-14-6.jpg" alt="图3-14-6"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next&#x3D;p-&gt;next;     &#x2F;&#x2F;把p-&gt;next赋值给p-&gt;prior的后继</span><br><span class="line">p-&gt;next-&gt;prior&#x3D;p-&gt;prior;    &#x2F;&#x2F;把p-&gt;prior赋值给p-&gt;next的前驱</span><br><span class="line">free(p);</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="图3-15-1.jpg" alt="图3-15-1"></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/uploads/alipay.jpg" alt="郭子淳 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/01/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E8%B4%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95/" rel="prev" title="《大话数据结构》贰——算法">
      <i class="fa fa-chevron-left"></i> 《大话数据结构》贰——算法
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线性表"><span class="nav-number">1.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性表的抽象数据类型"><span class="nav-number">1.2.</span> <span class="nav-text">线性表的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性表的顺序存储结构"><span class="nav-number">1.3.</span> <span class="nav-text">线性表的顺序存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序存储定义"><span class="nav-number">1.3.1.</span> <span class="nav-text">顺序存储定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序存储方式"><span class="nav-number">1.3.2.</span> <span class="nav-text">顺序存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组长度与线性表长度的区别"><span class="nav-number">1.3.3.</span> <span class="nav-text">数组长度与线性表长度的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址的计算方法"><span class="nav-number">1.3.4.</span> <span class="nav-text">地址的计算方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序存储结构的插入与删除"><span class="nav-number">1.4.</span> <span class="nav-text">顺序存储结构的插入与删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获得元素操作"><span class="nav-number">1.4.1.</span> <span class="nav-text">获得元素操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入操作"><span class="nav-number">1.4.2.</span> <span class="nav-text">插入操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除操作"><span class="nav-number">1.4.3.</span> <span class="nav-text">删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性表顺序存储结构的优缺点"><span class="nav-number">1.4.4.</span> <span class="nav-text">线性表顺序存储结构的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性表的链式存储结构"><span class="nav-number">1.5.</span> <span class="nav-text">线性表的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线性表链式存储结构定义"><span class="nav-number">1.5.1.</span> <span class="nav-text">线性表链式存储结构定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#头指针与头结点的异同"><span class="nav-number">1.5.2.</span> <span class="nav-text">头指针与头结点的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性表链式存储结构代码描述"><span class="nav-number">1.5.3.</span> <span class="nav-text">线性表链式存储结构代码描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单链表的读取"><span class="nav-number">1.6.</span> <span class="nav-text">单链表的读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单链表的插入与删除"><span class="nav-number">1.7.</span> <span class="nav-text">单链表的插入与删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表的插入"><span class="nav-number">1.7.1.</span> <span class="nav-text">单链表的插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表的删除"><span class="nav-number">1.7.2.</span> <span class="nav-text">单链表的删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单链表的整表创建"><span class="nav-number">1.8.</span> <span class="nav-text">单链表的整表创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单链表的整表删除"><span class="nav-number">1.9.</span> <span class="nav-text">单链表的整表删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单链表结构与顺序存储结构的优缺点"><span class="nav-number">1.10.</span> <span class="nav-text">单链表结构与顺序存储结构的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态链表"><span class="nav-number">1.11.</span> <span class="nav-text">静态链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态链表的插入操作"><span class="nav-number">1.11.1.</span> <span class="nav-text">静态链表的插入操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态链表的删除操作"><span class="nav-number">1.11.2.</span> <span class="nav-text">静态链表的删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态链表优缺点"><span class="nav-number">1.11.3.</span> <span class="nav-text">静态链表优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环链表"><span class="nav-number">1.12.</span> <span class="nav-text">循环链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向链表"><span class="nav-number">1.13.</span> <span class="nav-text">双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.14.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="郭子淳"
      src="/uploads/blog_face2.jpg">
  <p class="site-author-name" itemprop="name">郭子淳</p>
  <div class="site-description" itemprop="description">越努力，越幸运！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Chun-CE" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Chun-CE" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/6436162979" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;6436162979" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭子淳</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
